##########################
# Name: bashTK (Bash ToolKit) including bashMS (Bash Menu System) and bashDB (Bash DataBase)
# Version: 0.12
# Info: https://github.com/srvr-au/bashTK
# Donate: https://www.paypal.com/donate?hosted_button_id=P8USAAG7U2T28
##########################

declare -rg btkHost=$( hostname )
declare -rg btkIp=$( hostname -i )

declare -rg btkRed='\e[1;37;41m\e[K'
declare -rg btkGre='\e[1;37;42m\e[K'
declare -rg btkYel='\e[1;37;43m\e[K'
declare -rg btkBlu='\e[1;37;44m\e[K'
declare -rg btkPur='\e[1;37;45m\e[K'
declare -rg btkCya='\e[1;37;46m\e[K'
declare -rg btkLtRed='\e[0;30;101m\e[K'
declare -rg btkLtGre='\e[0;30;102m\e[K'
declare -rg btkLtYel='\e[0;30;103m\e[K'
declare -rg btkLtBlu='\e[0;30;104m\e[K'
declare -rg btkLtPur='\e[0;30;105m\e[K'
declare -rg btkLtCya='\e[0;30;106m\e[K'
declare -rg btkRes='\e[0m'
declare -rg btkRev='\e[1;7m\e[K'
declare -rg btkReturn='\n\e[K'

BTKerror(){
  echo -e "${btkRed} ERROR: ${btkRes}${btkLtRed} ${1}${btkRes}"
  BTKpause
}
BTKfatalError(){
  echo -e "${btkRed} FATAL ERROR: ${btkRes}${btkLtRed} ${1}${btkRes}\n"
  exit 1
}
BTKwarn(){
  echo -e "${btkYel} WARNING: ${btkRes}${btkLtYel} ${1}${btkRes}\n"
}
BTKsuccess(){
  echo -e "${btkGre} SUCCESS: ${btkRes}${btkLtGre} ${1}${btkRes}\n"
}
BTKinfo(){
  echo -e "${btkBlu} INFORMATION: ${btkRes}${btkLtBlu} ${1}${btkRes}\n"
}
BTKexit(){
  local reason=${1:-Exiting as per your request.}
  echo -e "\n${btkRed} ${reason}${btkRes}\n"
  exit 1
}
BTKheader(){
  echo -e "${btkLtPur} ${1} ${btkRes}\n${btkPur} ${btkRes}\n"
}
BTKpause(){
  echo -e "${btkRev} Check above lines. Press 'a' to Abort or any key to Clear & Continue. ${btkRes}"
  read -n 1 -s reply
  [[ $reply == 'a' ]] && BTKexit
  clear
  echo -e "${btkPur} Continuing... ${btkRes}"
}
BTKask(){
  echo -e "${btkCya} ${1}${btkRes}"
  echo -e "${btkRev} Enter y for yes, n for no, any other key to abort...${btkRes}"
  read -n 1 -s btkYN
  [[ "$btkYN" != [yn] ]] && BTKexit
  echo -e "\n"
}
BTKaskConfirm(){
  local confirm='n'
  until [[ $confirm == 'y' ]]; do
    echo -e "${btkCya} ${1}${btkRes}"
    read btkAnswer
    [[ $btkAnswer == '' ]] && btkAnswerEng='*No Input*' || btkAnswerEng=$btkAnswer
    echo -e "${btkRev} Your answer was $btkAnswerEng, is this correct? (y/n)... ${btkRes}"
    read -n 1 -s confirm
  done
  echo -e "\n"
}
BTKrun(){
  "$@"
  [[ $? -eq 0 ]] && BTKsuccess "Command Succeeded (${@})." || { echo >&2 -e "${btkRed}Command Failed (${@}). Exiting...${btkRes}"; exit 1; }
}
BTKcmdCheck(){
  [[ $? -eq 0 ]] && BTKsuccess "Command Succeeded (${1})." || BTKerror "Command Failed (${1})."
}
BTKbackupOrigConfig(){
  [[ ! -f ${1}.origbak ]] && cp $1 "${1}.origbak"
  [[ -f "${1}.origbak" ]] && BTKsuccess "${1}.origbak exists." || BTKerror "${1}.origbak DOES NOT exist. Backup config file failed."
}
BTKfileExists(){
  [[ -f "$1" ]] && BTKsuccess "$1 exists." || BTKerror "$1 does NOT exist."
}
BTKgrepCheck(){
  grep "$1" -q "$2" && BTKsuccess "$1 CORRECTLY found in $2" || BTKerror "$1 NOT found in $2"
}
BTKgrepCheckSOL () {
  grep "^$1" -q "$2" && BTKsuccess "$1 CORRECTLY found in $2" || BTKerror "$1 NOT found in $2"
}
BTKgrepCheckReverse () {
grep "$1" -q "$2" && BTKerror "$1 INCORRECTLY found in $2" || BTKsuccess "$1 correctly not found in $2"
}
BTKshowFile(){
echo -e "\n${btkBlu}*** Showing File contents $1 ***${btkRes}\n"
echo -e "${btkLtBlu}$( cat $1 )${btkRes}"
echo -e "\n${btkBlu}*** End showing file contents ***${btkRes}\n"
}
BTKmakeCron(){
crontab -l -u root | grep -F -i -v "$1" | { cat; echo "$2"; } | crontab -
}
BTKjumpTo(){
local label=$1
local cmd=$( sed -n "/$label:/{:a;n;p;ba};" $0 | grep -v ':$' )
eval "$cmd"
exit
}
BTKisInstalled(){
  dpkg --verify "$1" 2>/dev/null
}
BTKinstall(){
local -a installAsk=("$@")
local -a installTry
local -ga installOK
BTKinfo 'Package Installation...'
echo -e "${btkLtBlu} Updating Package Database... ${btkRes}"
apt update &>/dev/null
echo -e "${btkLtBlu} Checking if already installed... ${btkRes}"
for i in ${installAsk[@]}; do
  BTKisInstalled "$i" && BTKerror "$i Already installed." || installTry+=("$i")
done
BTKsuccess 'Checking complete...'
echo -e "${btkLtBlu} Installing the following software...${installTry[@]} ${btkRes}"
BTKpause
DEBIAN_FRONTEND=noninteractive apt install -y "${installTry[@]}"
for i in ${installTry[@]}; do
  if BTKisInstalled "$i"; then
    installOK+=("$i")
    BTKsuccess "$i installed"
  else
    BTKerror "$i NOT installed"
  fi
done
BTKinfo 'Package installation complete.'
}
BTKenable(){
systemctl enable --now $1
local status1=$( systemctl is-enabled $1 )
local status2=$( systemctl is-active $1 )
BTKinfo "$1 is ${status1} and ${status2}"
}
BTKaddRestart(){
if [ ! -d /etc/systemd/system/${1}.service.d ]; then
  mkdir /etc/systemd/system/${1}.service.d
  BTKcmdCheck "mkdir ${1}.service.d"
fi
if [[ -d /etc/systemd/system/${1}.service.d && ! -L /etc/systemd/system/${1}.service.d ]] ; then
  if [ ! -f /etc/systemd/system/${1}.service.d/srvr.conf ]; then
    echo -e "[Service]\nRestart=on-failure\nRestartSec=30s" > /etc/systemd/system/${1}.service.d/srvr.conf
    BTKsuccess 'Restart file added successfully.'
    BTKshowFile "/etc/systemd/system/${1}.service.d/srvr.conf"
  else
    BTKwarn "/etc/systemd/system/${1}.service.d/srvr.conf already exists."
  fi
fi
}
BTKgetStatus(){
BTKinfo "${1} is $( systemctl is-active ${1} )"
}

BTKrandLetters(){
  local length=${1:-20}
  local chars='A-HJ-NP-Za-km-z'
  echo $(< /dev/urandom tr -dc ${chars} | head -c${length})
}
BTKrandNumbers(){
  local length=${1:-10}
  local chars='0-9'
  echo $(< /dev/urandom tr -dc ${chars} | head -c${length})
}
BTKrandAlpha(){
  local length=${1:-20}
  local chars='A-HJ-NP-Za-km-z2-9'
  echo $(< /dev/urandom tr -dc ${chars} | head -c${length})
}
BTKrandAlpha+(){
  local length=${1:-20}
  local chars='A-HJ-NP-Za-km-z2-9@+=$#&><'
  echo $(< /dev/urandom tr -dc ${chars} | head -c${length})
}
BTKgetDate(){
  local startDate=$1 # in YYYY-mm-dd format
  local changeBy=$2 # in +1m format (+ or - number time as d,w,m,y)
  local len=$((${#changeBy}-1))
  local firstPart="${changeBy:0:$len}"
  local letter="${changeBy:$len:1}"
  case $letter in
    d) local secondPart='days';;
    w) local secondPart='weeks';;
    m) local secondPart='months';;
    y) local secondPart='years';;
    *) echo 'Problem with second argument'; exit;;
  esac
  date --date="$( date +${startDate} ) $firstPart $secondPart" +%Y-%m-%d
}
BTKdaysBetween(){
  local firstDate=$( date --date="$1" +%s )
  local secondDate=$( date --date="$2" +%s )
  local seconds=$((secondDate-firstDate))
  echo $((seconds/86400))
}

# used for reading a heredoc into var ie BTKdefine VAR <<'EOF' etc...
BTKdefine(){ IFS='\n' read -r -d '' ${1} || true; }

declare -ag btkMenuOptions
BTKmenu(){
  local doConfirm=${1:-"y"}
  local heading=${2:-"Menu Heading"}
  local prompt=${3:-"Press a letter to choose: "}
  while true; do
  clear
  echo -e "${btkPur} ${heading}${btkRes}"
  local chars=( {a..p} {r..w} {y..z} )
  local menuChars=()
  for i in "${!btkMenuOptions[@]}"; do
    echo -e "${btkLtpur} ["${chars[i]}"] - ${btkMenuOptions[$i]}${btkRes}"
    menuChars+=("${chars[i]}")
  done
menuChars+=('q' 'x')
echo -e "${btkLtPur} [q] - Quit this Menu${btkRes}"
echo -e "${btkLtPur} [x] - Exit this Script${btkRes}"
  echo -e "${btkCya} ${prompt}${btkRes}"
  echo -e "${btkPur} ${btkRes}"
read -n1 -s btkMenuAnswer
local count=0
for i in "${menuChars[@]}"; do
    if [ "$i" == "${btkMenuAnswer}" ] ; then
      [[ "$i" == 'x' ]] && BTKexit
      [[ "$i" == 'q' ]] && return
      if [[ $doConfirm == 'y' ]]; then
        echo -e "${btkGre} You chose ${btkRes}${btkLtGre} ${btkMenuOptions[$count]} ${btkRes}\n${btkRev} Is this correct (y or n)?${btkRes}"
        read -n1 -s confirm
        [[ $confirm == 'y' ]] && return
      else
        return
      fi
    fi
((count++))
done
done
}

# start bashDB

BDBconnect(){
  set -u
  declare -g bdbFile=${1}
  if [[ ! -f "${bdbFile}" ]]; then
    mkdir -p "$( dirname "${bdbFile}" )"
    touch "${bdbFile}"
    chmod 600 "${bdbFile}"
  fi
  [[ -f "${bdbFile}" ]] && BTKsuccess "DB File ${bdbFile} created or exists." || BTKerror "DB File ${bdbFile} does not exist."
}
BDBinsert(){
  if grep -q "${1}=" "${bdbFile}"; then
  	BTKerror "The file ${bdbFile} already contains ${1}, use update rather than insert."
  else
    local entry="${1}=${2}"
  	echo "${entry}" >> "${bdbFile}"
  	grep -q "${1}=" "$bdbFile" && BTKsuccess "Entry $entry correctly inserted into ${bdbFile}." || BTKerror "Entry $entry FAILED to insert into ${bdbFile}."
  fi
}
BDBdelete(){
  set -u
  sed -i /${1}=/d "${bdbFile}"
  grep -q "${1}=" "${bdbFile}" && BTKerror "Entry for ${1} FAILED to erase." || BTKsuccess "Entry for ${1} correctly erased."
}
BDBupdate(){
  BDBdelete "${1}"
  BDBinsert "${1}" "${2}"
}
BDBdrop(){
  set -u
  rm -rf "${bdbFile}"
  [[ ! -f "${bdbFile}" ]] && BTKsuccess "DB File ${bdbFile} correctly erased" || BTKwarn "DB File ${bdbFile} FAILED to erase."
}
BDBselectAll(){
  set -u
  while IFS= read -r line; do
    local index=$( awk -F'=' '{print $1}' <<< "$line" )
    declare -g${1} $index
    eval $( grep "${index}=" "${bdbFile}" )
  done < "${bdbFile}"
}
BDBselectRow(){
  set -u
  declare -g ${2} ${1}
  eval $( grep "${1}=" "${bdbFile}" )
}
BDBclean(){
  set -u
  sed '/^$/d' ${bdbFile}
  grep -c "^$" "${bdbFile}" && BTKwarn "Empty lines FAILED to be removed" || BTKsuccess "All empty lines removed from ${bdbFile}"
}

# end bashDB

